[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Matt Sams",
    "section": "",
    "text": "Hey, I’m Matt. I moonlight as a sport scientist in America’s favorite version of football. In previous lives, I’ve worked as an analyst in baseball, spent a little time as a professor, and spent a really long time as an applied sport scientist/S&C coach. I’ve had the chance to work with athletes in a range of sports, including soccer, basketball, volleyball, bobsled and skeleton, and XC skiing.\nMy main focus is on maximizing player performance while managing fatigue and injury risk. To that end, I’ve spent a lot of time developing and implementing athlete monitoring systems, building data visualizations and reports for stakeholders at all organizational levels, and performing in-depth post-mortem analyses to drive future programming decisions.\n\n\n Experience\nDirector of Sport Science (2021 - Current)\n   | New York Jets\nAnalyst, Performance Science (2019 - 2021)\n   | Kansas City Royals\nPerformance Coach (2018 - 2019)\n   | Chinese Olympic Committee\nAssistant Professor (2017 - 2018)\n   | LaGrange College\nLead Sport Scientist - Men’s Soccer (2012 - 2017)\n   | East Tennessee State University\n\n\n\n Education\nPhD in Sport Physiology & Performance (2017)\n   | East Tennessee State University\nMA in Exercise Physiology (2014)\n   | East Tennessee State University\nBS in Exercise Science (2011)\n   | East Tennessee State University"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ye Olde Blog",
    "section": "",
    "text": "A Look at {box} (WIP)\n\n\n\n\n\n\n\nR\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nMatt Sams\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/box_part1/index.html#a-brief-interlude-on-scoping",
    "href": "posts/box_part1/index.html#a-brief-interlude-on-scoping",
    "title": "A Look at {box} (WIP)",
    "section": "A Brief Interlude on Scoping",
    "text": "A Brief Interlude on Scoping\n\n\n\n\n\nWe’re not going to get super deep into a scoping discussion, so if you’re interested in diving deeper, check this out. At any rate, scoping has to do with how object names are resolved in a program. What the hell does that mean, right? For a very simple example…\n\nx <- 5\n\nx\n\n[1] 5\n\n\n…we’ve created a variable with the name x in our global environment (more on that in a second). Because R is the way it is (highly scientific description, I know), we can immediately redefine x:\n\nx <- 15\n\nx\n\n[1] 15\n\n\nWe’re not going to get into the hows and whys of what’s happening under the hood, just know we’ve redefined the value of our x variable to 15. Where scoping comes into play is in the following two examples:\n\n# R's shorthand for functions...you probably won't see me \n# do this all that often because old habits die hard\ndouble_x <- \\(x) x * 2\n\ndouble_x(5)\n\n[1] 10\n\n\n\nhidden_x <- \\(y) y * 2 + x\n\nhidden_x(5)\n\n[1] 25\n\n\nIn the first example, we provided the value 5 to the function argument x, which was doubled and returned. Makes sense. So how did the second hidden_x() function know to add 15 to y * 2? Through the magic of R’s scoping rules!\n\nThree Environments to Rule Them All\nIn R, you essentially have three environments: the local environment, the global environment, and the package/library/namespace environment. Think of the local environment as the inside of a function; that isn’t quite right, but it’s close enough for us. Variables and functions in the local environment are only available in said local environment.\nThe next step up–the global environment–is everything in the Environment panel if you’re using the default layout for RStudio. Variables and functions in the global environment are accessible and can be called from anywhere in your R process.\n\n\n\n\n\nSo when you save needlessly_long_named_dataframe_final_v2 through the assignment operator (<-) and it appears in the global environment panel, needlessly_long_named_dataframe_final_v2 is now available in your global environment and can be called inside other functions.\nFinally, we have the package/library environment, which contains the namespaces of the currently loaded packages (library(whatever)). Most people access package namespaces through calling library() and calling the newly-available functions:\n\nlibrary(tidytable)\n\n.df <- mutate.(.df, new_col = col * 5)\n\nBut it’s also possible to namespace specific functions:\n\n.df <- tidytable::mutate.(.df, new_col = col * 5)\n\n\n\n…OK?\nSo who cares, right? You should care. R’s scoping rules (and evaluation rules, but beyond what we care about) are why you’ve probably gotten some really wonky results before when doing something like this:\n\nexample_tidytable <- tidytable(name = c(\"Bob\", \"Cindy\", \"Bill\", \"Marsha\"))\n\nname <- \"Bob\"\n\nfilter.(example_tidytable, name == name)\n\n# A tidytable: 4 × 1\n  name  \n  <chr> \n1 Bob   \n2 Cindy \n3 Bill  \n4 Marsha\n\n\nLikewise, it’s why our second function above (hidden_x()) is able to add x to the user-provided value without having to add an x argument to the function.\n\nhidden_x(25)\n\n[1] 65\n\n\nJust in case you were wondering, we can solve our toy example problem via…\n\n# OR name == !!name\nfilter.(example_tidytable, name == {{name}})\n\n# A tidytable: 1 × 1\n  name \n  <chr>\n1 Bob  \n\n\nAnyway, this is because–when searching for a variable (name, x, etc.)–R searches the environments in the order I described above: local > global > namespace. In the filtering example, since name exists as a field in the tidytable (the innermost local environment), R stops its search and uses name in the equality. Since the vector is equal to itself (if it isn’t, oh boy, do we have problems), you get back the entire tidytable. Our solution in the last chunk essentially tells R to use name from one step up the scoping chain; although, we could have just as easily solved the problem by using a different variable name.\n\nmy_name <- \"Bob\"\n\nfilter.(example_tidytable, name == my_name)\n\n# A tidytable: 1 × 1\n  name \n  <chr>\n1 Bob  \n\n\nAt any rate, in the case of hidden_x(), R doesn’t find x declared inside the local/function environment, so it steps up to the global environment to see if x exists there. Since we defined x <- 15 earlier, it uses that value of x inside the function. Hopefully you see where we’re going with this.\n\n\nI Got 99 Problems and a Namespace is One\nLet’s circle all the way back to the workflow-breaking problem I mentioned at the start: loading {tidytable} while rendering a {quarto} document was throwing an error. This has to do with both scoping and how packages are loaded in R. When calling a function, R performs the same step-up search approach I described for variables: local functions > global functions > namespace functions. This lets you define your own local or global functions that may share names with functions from packages. The rub is how R handles packages that share functions with the same name.\nWhen starting a new R process, the {base} package is loaded first, followed by a few additional support packages ({stats}, {utils}, etc.). This essentially creates a list of functions that are available for the user to call based on what packages have been loaded. What’s really important to know is each newly-loaded package is moved to the front of the list. This is fine and dandy in cases like {base}, {stats}, etc. because they don’t share any overlapping functions. When you load a package that has a function with the same name as a previously-loaded package, however, it creates a naming conflict. R handles these naming conflicts by masking the previously loaded function:\n```{r}\nlibrary(tidytable)\n\n...\n\nThe following objects are masked from ‘package:stats’:\n\n    dt, filter, lag\n\nThe following object is masked from ‘package:base’:\n\n    %in%\n```\nSo now, if you call dt(), filter(), lag(), or %in%, you’re going to get the {tidytable} variants. You’ve probably seen something similar when calling library(tidyverse). In some cases, this masking is no big deal. In others–like our not-so-hypothetical–it can break everything."
  },
  {
    "objectID": "posts/box_part1/index.html#solving-our-namespace-problem",
    "href": "posts/box_part1/index.html#solving-our-namespace-problem",
    "title": "A Look at {box} (WIP)",
    "section": "Solving Our Namespace Problem",
    "text": "Solving Our Namespace Problem\nSo how do you handle situations where multiple packages have a function with the same name AND you need functionality from both versions (e.g. filter from {stats} and {dplyr})? One method is explicitly calling the package namespace each time you invoke a function.\n\ncondition <- \"trained\"\nratio <- 0.25\n\n.df |> \n  dplyr::filter(condition == {{condition}}) |> \n  dplyr::summarize(filtered_values = stats::filter(value * ratio, 1 - ratio, \"recursive\", init = value[1]))\n\nWhile that’s generally the recommended approach when building packages, it gets pretty cumbersome for day-to-day programming. Another option is to use {conflicted}.\n\nlibrary(tidytable)\nlibrary(tidyverse) # Don't actually do this\n\nconflicted::conflicts_prefer(\n  stats::filter,\n  tidytable::lag,\n  tidytable::map_vec\n)\n\n# You get the idea\n\nThat’s definitely better, but can cause you to overlook namespace conflicts until you get an error (or not) when running a report.\nThank all that’s holy, we’ve finally made it to why {box} is a thing."
  }
]