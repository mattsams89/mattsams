[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Matt Sams",
    "section": "",
    "text": "Hey, I’m Matt. I moonlight as a sport scientist in America’s favorite version of football. In previous lives, I’ve worked as an analyst in baseball, spent a little time as a professor, and spent a really long time as an applied sport scientist/S&C coach. I’ve had the chance to work with athletes in a range of sports, including soccer, basketball, volleyball, bobsled and skeleton, and XC skiing.\nMy main focus is on maximizing player performance while managing fatigue and injury risk. To that end, I’ve spent a lot of time developing and implementing athlete monitoring systems, building data visualizations and reports for stakeholders at all organizational levels, and performing in-depth post-mortem analyses to drive future programming decisions.\n\n\n Experience\nDirector of Sport Science (2021 - Current)\n   | New York Jets\nAnalyst, Performance Science (2019 - 2021)\n   | Kansas City Royals\nPerformance Coach (2018 - 2019)\n   | Chinese Olympic Committee\nAssistant Professor (2017 - 2018)\n   | LaGrange College\nLead Sport Scientist - Men’s Soccer (2012 - 2017)\n   | East Tennessee State University\n\n\n\n Education\nPhD in Sport Physiology & Performance (2017)\n   | East Tennessee State University\nMA in Exercise Physiology (2014)\n   | East Tennessee State University\nBS in Exercise Science (2011)\n   | East Tennessee State University"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ye Olde Blog",
    "section": "",
    "text": "A Look at {box} (WIP)\n\n\n\n\n\n\n\nR\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nMatt Sams\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/box_part1/index.html#a-brief-interlude-on-scoping",
    "href": "posts/box_part1/index.html#a-brief-interlude-on-scoping",
    "title": "A Look at {box} (WIP)",
    "section": "A Brief Interlude on Scoping",
    "text": "A Brief Interlude on Scoping\n\n\n\n\n\nWe’re not going to get super deep into a scoping discussion, so if you’re interested in diving deeper, check this out. At any rate, scoping has to do with how object names are resolved in a program. What the hell does that mean, right? For a very simple example…\n\nx <- 5\n\nx\n\n[1] 5\n\n\n…we’ve created a variable with the name x in our global environment (more on that in a second). Because R is the way it is (highly scientific description, I know), we can immediately redefine x:\n\nx <- 15\n\nx\n\n[1] 15\n\n\nWe’re not going to get into the hows and whys of what’s happening under the hood, just know we’ve created a variable called x in the global environment and have assigned it the value 15. Where scoping comes into play is in the following two examples:\n\n# R's shorthand for functions...you probably won't see me \n# do this all that often because old habits die hard\ndouble_x <- \\(x) x * 2\n\ndouble_x(5)\n\n[1] 10\n\n\n\nhidden_x <- \\(y) y * 2 + x\n\nhidden_x(5)\n\n[1] 25\n\n\nIn the first example, we provided the value 5 to the function argument x, which was doubled and returned. Makes sense. So how did the second hidden_x() function know to add 15 to y * 2? Through the magic of R’s scoping rules!\n\nThree Environments to Rule Them All\nIn R, you essentially have three environments: the local environment, the global environment, and the package/library/namespace environment. Think of the local environment as the inside of a function; that isn’t quite right since you can have multiple local environments through nested functions, but it’s close enough for us. The next step up–the global environment–is everything in the Environment panel if you’re using the default layout for RStudio.\n\n\n\n\n\nSo when you save needlessly_long_named_dataframe_final_v2 through the assignment operator (<-) and it appears in the global environment panel, needlessly_long_named_dataframe_final_v2 is now available in your global environment.\nFinally, we have the package/library environment, which contains the namespaces of the currently loaded packages (library(whatever)). Most people access package namespaces through calling library() and calling the newly-available functions:\n\nlibrary(tidytable)\n\n.df <- mutate.(.df, new_col = col * 5)\n\nBut it’s also possible to namespace specific functions:\n\n.df <- tidytable::mutate.(.df, new_col = col * 5)\n\n\n\n…OK?\nSo who cares, right? You should care. R’s scoping rules (and greedy evaluation, but again, beyond what we care about) are why you’ve probably gotten some really wonky results before when doing something like this:\n\nexample_tidytable <- tidytable(name = c(\"Bob\", \"Cindy\", \"Bill\", \"Marsha\"))\n\nname <- \"Bob\"\n\nfilter.(example_tidytable, name == name)\n\n# A tidytable: 4 × 1\n  name  \n  <chr> \n1 Bob   \n2 Cindy \n3 Bill  \n4 Marsha\n\n\nLikewise, it’s why our second function above (hidden_x()) is able to add x to the user-provided value without having to add an x argument to the function.\n\nhidden_x(25)\n\n[1] 65\n\n\nJust in case you were wondering, we can solve our toy example problem via…\n\n# OR name == !!name\nfilter.(example_tidytable, name == {{name}})\n\n# A tidytable: 1 × 1\n  name \n  <chr>\n1 Bob  \n\n\nThis is because–when searching for a variable (name, x, etc.)–R searches the environments in the order I described above: local > global > namespace. In the filtering example, since name exists as a field in the tidytable (the innermost local environment), R stops its search and uses name in the equality. Since the vector is equal to itself (if it isn’t, oh boy, do we have problems), you get back the entire tidytable. Our solution in the last chunk essentially tells R to wait and use name from one step up the scoping chain; although, we could have just as easily solved the problem by using a different variable name.\n\nmy_name <- \"Bob\"\n\nfilter.(example_tidytable, name == my_name)\n\n# A tidytable: 1 × 1\n  name \n  <chr>\n1 Bob  \n\n\nAt any rate, in the case of hidden_x(), R doesn’t find x declared inside the local/function environment, so it steps up to the global environment to see if x exists there. Since we defined x <- 15 earlier, it uses that value of x inside the function. Hopefully you see where we’re going with this.\n\n\nI Got 99 Problems and a Namespace is One\nLet’s circle all the way back to the workflow-breaking problem I mentioned at the start: loading {tidytable} while rendering a {quarto} document was throwing an error. This has to do with how packages are loaded in R. {base} is loaded first, then a few additional packages ({stats}, {utils}, etc.) are loaded on start-up. Each newly-loaded package is moved to the front of the line in the list of loaded packages. If there are any name conflicts between packages, the new package functions mask the previously loaded functions:\n```{r}\nlibrary(tidytable)\n\n...\n\nThe following objects are masked from ‘package:stats’:\n\n    dt, filter, lag\n\nThe following object is masked from ‘package:base’:\n\n    %in%\n```\nYou’ve probably seen something similar when calling library(tidyverse). In some cases, this masking is no big deal. In others, it can break everything."
  },
  {
    "objectID": "posts/box_part1/index.html#solving-our-namespace-problem",
    "href": "posts/box_part1/index.html#solving-our-namespace-problem",
    "title": "A Look at {box} (WIP)",
    "section": "Solving Our Namespace Problem",
    "text": "Solving Our Namespace Problem\nSo how do you handle situations where multiple packages have a function with the same name AND you need functionality from both versions (e.g. filter from {stats} and {dplyr})? One method is explicitly calling the package namespace each time you invoke a function.\n\ncondition <- \"trained\"\nratio <- 0.25\n\n.df |> \n  dplyr::filter(condition == {{condition}}) |> \n  dplyr::summarize(filtered_values = stats::filter(value * ratio, 1 - ratio, \"recursive\", init = value[1]))\n\nWhile that’s generally the recommended approach when building packages, it gets pretty cumbersome for day-to-day programming. Another option is to use {conflicted}.\n\nlibrary(tidytable)\nlibrary(tidyverse)\n\nconflicted::conflicts_prefer(\n  stats::filter,\n  tidytable::lag,\n  tidytable::map_vec\n)\n\n# You get the idea\n\nThat’s still pretty cumbersome and can cause you to overlook namespace conflicts until you get an error (or not) when running a report. Thank all that’s holy, we’ve finally made it to why {box} is a thing."
  }
]